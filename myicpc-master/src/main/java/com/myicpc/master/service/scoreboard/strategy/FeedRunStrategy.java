package com.myicpc.master.service.scoreboard.strategy;

import com.myicpc.dto.eventFeed.EventFeedSubmission;
import com.myicpc.enums.NotificationType;
import com.myicpc.master.dao.EventFeedDao;
import com.myicpc.master.exception.EventFeedException;
import com.myicpc.model.contest.Contest;
import com.myicpc.model.eventFeed.LastTeamProblem;
import com.myicpc.model.eventFeed.Problem;
import com.myicpc.model.eventFeed.Team;
import com.myicpc.model.eventFeed.TeamProblem;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;

public abstract class FeedRunStrategy {
    private static final Logger logger = LoggerFactory.getLogger(FeedRunStrategy.class);

    @Inject
    protected EventFeedDao eventFeedDao;

    public EventFeedSubmission executeTeamProblem(TeamProblem teamProblem, Contest contest) throws EventFeedException {
        List<Team> teamsToBroadcast = new ArrayList<Team>();
        // fresh = submitted run, done = judged run
        if ("fresh".equalsIgnoreCase(teamProblem.getStatus())) {
            System.out.println("fresh");
            teamProblem = eventFeedDao.saveContestEntity(teamProblem);
            changeLastSubmissionByTeam(teamProblem);
            sendAutogeneratedMessages(teamProblem, contest, NotificationType.SCOREBOARD_SUBMIT);
        } else if ("done".equalsIgnoreCase(teamProblem.getStatus())) {
            System.out.println("done");
            // get submission, which is persist as pending
            TeamProblem tp = eventFeedDao.findTeamProblemBySystemIdAndTeamIdAndProblemId(
                                teamProblem.getSystemId(),
                                teamProblem.getTeam().getId(),
                                teamProblem.getProblem().getId()
                            );
            // if there is no pending submission for the same run, persist it
            if (tp == null) {
                tp = eventFeedDao.saveContestEntity(teamProblem);
            }
            // otherwise update it
            changeLastSubmissionByTeam(tp);
            tp.setJudged(teamProblem.getJudged());
            tp.setSolved(teamProblem.getSolved());
            tp.setLanguage(teamProblem.getLanguage());
            tp.setResultCode(teamProblem.getResultCode());
            tp.setPenalty(teamProblem.getPenalty());
            tp.setAttempts(countTeamProblemAttempts(tp));
            tp.setOldRank(tp.getTeam().getRank());
            if (tp.getSolved()) {
                teamsToBroadcast.addAll(processScoreboardChanges(tp, teamProblem, contest));
            }
            tp.setNewRank(tp.getTeam().getRank());
            teamProblem = eventFeedDao.saveContestEntity(tp);
            if (teamProblem.getSolved()) {
                sendAutogeneratedMessages(teamProblem, contest, NotificationType.SCOREBOARD_SUCCESS);
            }
        }
//        onSubmission(teamProblem, teamsToBroadcast);
        return new EventFeedSubmission(teamProblem, teamsToBroadcast);
    }

    /**
     * Update {@link LastTeamProblem} by {@link TeamProblem}
     *
     * @param teamProblem the latest team problem
     */
    protected void changeLastSubmissionByTeam(final TeamProblem teamProblem) {
        LastTeamProblem lastTeamProblem = eventFeedDao.findLastTeamProblemByTeamAndProblem(teamProblem.getTeam(), teamProblem.getProblem());
        if (lastTeamProblem == null) {
            lastTeamProblem = new LastTeamProblem();
            lastTeamProblem.setTeam(teamProblem.getTeam());
            lastTeamProblem.setProblem(teamProblem.getProblem());
        }
        // the problem was already solved or we have already a newer submission
        if (lastTeamProblem.getTeamProblem() != null
                && (lastTeamProblem.getTeamProblem().getSolved() || lastTeamProblem.getTeamProblem().getTime().compareTo(teamProblem.getTime()) == 1)) {
            return;
        }
        lastTeamProblem.setTeamProblem(teamProblem);
        eventFeedDao.saveContestEntity(lastTeamProblem);
    }

    /**
     * Counts a number of tries team had for this run
     *
     * @param tp run
     * @return number of tries
     */
    protected int countTeamProblemAttempts(final TeamProblem tp) {
        List<TeamProblem> list = eventFeedDao.findTeamProblemByTeamAndProblemOrderByTimeAsc(tp.getTeam(), tp.getProblem());
        int count = 0;
        for (TeamProblem teamProblem : list) {
            if (teamProblem.getPenalty() && !teamProblem.getSolved()) {
                count++;
            }
            if (teamProblem.getSolved()) {
                count++;
                break;
            }
        }
        return count;
    }

    /**
     * Process the successful run
     *
     * @param teamProblemFromDB   team loaded from database
     * @param teamProblemFromFeed team parsed from event feed
     * @param contest
     * @return list of affected teams
     */
    protected abstract List<Team> processScoreboardChanges(final TeamProblem teamProblemFromDB, final TeamProblem teamProblemFromFeed, Contest contest) throws EventFeedException;

    /**
     * Remove mark on the run about the first solved problem for given problem
     *
     * @param problem
     *            problem
     */
    protected void removeFirstSolvedProblem(final Problem problem) {
        // TODO port
//        List<TeamProblem> firstSolvedTeamProblems = teamProblemRepository.findByProblemAndFirstSolved(problem, true);
//        for (TeamProblem fstp : firstSolvedTeamProblems) {
//            fstp.setFirstSolved(false);
//            teamProblemRepository.save(fstp);
//            PublishService.broadcastTeamProblem(fstp, new ArrayList<Team>());
//        }
    }

    protected void sendAutogeneratedMessages(TeamProblem teamProblem, Contest contest, NotificationType notificationType) {
        if (contest.getContestSettings() != null && contest.getContestSettings().isGenerateMessages()) {
            try {
                if (notificationType.isScoreboardSubmitted()) {
//                    onPendingSubmissionNotification(teamProblem);
//                    notificationService.sendNotificationOnTeamProblemSubmitted(teamProblem);
                } else if (notificationType.isScoreboardSuccess()) {
//                    onSuccessSubmissionNotification(teamProblem);
//                    notificationService.sendNotificationOnTeamProblemSolved(teamProblem);
                }
            } catch (Throwable throwable) {
                logger.error("Message for run with ID " + teamProblem.getId() + " was not generated and broadcasted.", throwable);
            }
        }
    }
}
