package com.myicpc.service.scoreboard.eventFeed;

import com.myicpc.commons.utils.WebServiceUtils;
import com.myicpc.model.contest.Contest;
import com.myicpc.model.eventFeed.LastTeamProblem;
import com.myicpc.model.eventFeed.Team;
import com.myicpc.model.eventFeed.TeamProblem;
import com.myicpc.model.social.Notification;
import com.myicpc.repository.eventFeed.LastTeamProblemRepository;
import com.myicpc.repository.eventFeed.TeamProblemRepository;
import com.myicpc.repository.eventFeed.TeamRepository;
import com.myicpc.service.notification.NotificationService;
import com.myicpc.service.publish.PublishService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

public abstract class FeedRunStrategy {
    private static final Logger logger = LoggerFactory.getLogger(FeedRunStrategy.class);

    @Autowired
    private PublishService publishService;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    protected TeamProblemRepository teamProblemRepository;

    @Autowired
    protected LastTeamProblemRepository lastTeamProblemRepository;

    @Autowired
    protected TeamRepository teamRepository;

    public TeamProblem executeTeamProblem(TeamProblem teamProblem, Contest contest) {
        List<Team> teamsToBroadcast = new ArrayList<Team>();
        // fresh = submitted run, done = judged run
        if ("fresh".equalsIgnoreCase(teamProblem.getStatus())) {
            teamProblem = teamProblemRepository.save(teamProblem);
            changeLastSubmissionByTeam(teamProblem);
            sendAutogeneratedMessages(teamProblem, contest, Notification.NotificationType.SCOREBOARD_SUBMIT);
        } else if ("done".equalsIgnoreCase(teamProblem.getStatus())) {
            // get submission, which is persist as pending
            TeamProblem tp = teamProblemRepository.findBySystemIdAndTeamContest(teamProblem.getSystemId(), contest);
            // if there is no pending submission for the same run, persist it
            if (tp == null) {
                tp = teamProblemRepository.save(teamProblem);
            }
            changeLastSubmissionByTeam(tp);
            tp.setJudged(teamProblem.getJudged());
            tp.setSolved(teamProblem.getSolved());
            tp.setLanguage(teamProblem.getLanguage());
            tp.setResultCode(teamProblem.getResultCode());
            tp.setPenalty(teamProblem.getPenalty());
            tp.setAttempts(countTeamProblemAttempts(tp));
            tp.setOldRank(tp.getTeam().getRank());
            if (tp.getSolved()) {
                teamsToBroadcast.addAll(processScoreboardChanges(tp, teamProblem, contest));
            }
            tp.setNewRank(tp.getTeam().getRank());
            teamProblem = teamProblemRepository.save(tp);
            if (teamProblem.getSolved()) {
                sendAutogeneratedMessages(teamProblem, contest, Notification.NotificationType.SCOREBOARD_SUCCESS);
            }
        }
        publishService.broadcastTeamProblem(teamProblem, teamsToBroadcast);
        return teamProblem;
    }

    /**
     * Update {@link LastTeamProblem} by {@link TeamProblem}
     *
     * @param teamProblem the latest team problem
     */
    protected void changeLastSubmissionByTeam(final TeamProblem teamProblem) {
        LastTeamProblem lastTeamProblem = lastTeamProblemRepository.findByTeamAndProblem(teamProblem.getTeam(), teamProblem.getProblem());
        if (lastTeamProblem == null) {
            lastTeamProblem = new LastTeamProblem();
            lastTeamProblem.setTeam(teamProblem.getTeam());
            lastTeamProblem.setProblem(teamProblem.getProblem());
        }
        // the problem was already solved or we have already a newer submission
        if (lastTeamProblem.getTeamProblem() != null
                && (lastTeamProblem.getTeamProblem().getSolved() || lastTeamProblem.getTeamProblem().getTime().compareTo(teamProblem.getTime()) == 1)) {
            return;
        }
        lastTeamProblem.setTeamProblem(teamProblem);
        lastTeamProblemRepository.save(lastTeamProblem);
    }

    /**
     * Counts a number of tries team had for this run
     *
     * @param tp run
     * @return number of tries
     */
    protected int countTeamProblemAttempts(final TeamProblem tp) {
        Iterable<TeamProblem> list = teamProblemRepository.findByTeamAndProblemOrderByTimeAsc(tp.getTeam(), tp.getProblem());
        int count = 0;
        for (TeamProblem teamProblem : list) {
            if (teamProblem.getPenalty() && !teamProblem.getSolved()) {
                count++;
            }
            if (teamProblem.getSolved()) {
                count++;
                break;
            }
        }
        return count;
    }

    /**
     * Process the successful run
     *
     * @param teamProblemFromDB   team loaded from database
     * @param teamProblemFromFeed team parsed from event feed
     * @param contest
     * @return list of affected teams
     */
    protected abstract List<Team> processScoreboardChanges(final TeamProblem teamProblemFromDB, final TeamProblem teamProblemFromFeed, Contest contest);

    protected void sendAutogeneratedMessages(TeamProblem teamProblem, Contest contest, Notification.NotificationType notificationType) {
        if (contest.getContestSettings() != null && contest.getContestSettings().isGenerateMessages()) {
            try {
                if (notificationType.isScoreboardSubmitted()) {
                    notificationService.sendNotificationOnTeamProblemSubmitted(teamProblem);
                } else if (notificationType.isScoreboardSuccess()) {
                    notificationService.sendNotificationOnTeamProblemSolved(teamProblem);
                }
            } catch (Throwable throwable) {
                logger.error("Message for run with ID " + teamProblem.getId() + " was not generated and broadcasted.", throwable);
            }
        }
    }
}
